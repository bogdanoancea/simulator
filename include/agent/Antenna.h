/*
 * Copyright (C) 2019  Bogdan Oancea

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version and under the EUPL free software license version 1.0 or later.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/> and
 * <https://ec.europa.eu/info/european-union-public-licence_en>
 *
 * A data simulator for mobile phone network events
 *
 * Antenna.h
 *
 *  Created on: Apr 5, 2019
 *      Author: Bogdan Oancea
 *      Email : bogdan.oancea@gmail.com
 */

#ifndef ANTENNA_H_
#define ANTENNA_H_

#include <agent/HoldableAgent.h>
#include <agent/ImmovableAgent.h>
#include <agent/MobileOperator.h>
#include <AntennaType.h>
#include <events/EventFactory.h>
#include <events/EventType.h>
#include <geos/geom/Coordinate.h>
#include <NetworkType.h>
#include <iostream>
#include <string>
#include <utility>
#include <vector>
#include <parsers/AntennaConfiguration.h>
#include <parsers/SimulationConfiguration.h>


using namespace geos;
using namespace geos::geom;
using namespace tinyxml2;


/**
 * This class simulates an antenna (a base transceiver station, or shortly BTS) of the mobile phone network.
 * It has a fixed location on the map and registers the events generated by the interaction with
 * the mobile devices in a .csv file. Each antenna has its own file where it saves the events and the name of this file.
 * The name of this file is composed by concatenating "Antenna", its id, "_MNO_" and the MNO name read from the
 * configuration file.
 * The are two types of antennas: omnidirectional and directional.
 * An omnidirectional antenna emits homogeneous signal in all directions. We model the signal using two measures:
 * \li the signal strength
 * \li the signal dominance
 *
 * The signal strength at distance \a r from the antenna's location is given by :
 *
 * \f$ RSS(r) = 30 + 10 log10(P) - 10 gamma log10(r)\f$
 * where P is the power of the antenna in Watts and gamma is the attenuation factor of the signal (also called the path loss exponent),
 * while the signal dominance is given by:
 *
 *  \f$ SDM(r) = 1/(1 + exp (-Ssteep ( RSS(r) - Smid)))\f$
 *
 *  where Ssteep and Smid are parameters that should be given in the configuration file.
 *  For a complete definition of the signal dominance one can consult:
 *  Tennekes M, Gootzen YAPM, Shah SH (2020) A Bayesian approach to location estimation of mobile devices from
 *  mobile network operator data. Research Report, Statistics Netherlands (CBS).
 *  A directional antenna has a specific signal emission pattern and one can find a description of it in the work mentioned above.
 *
 */
class Antenna: public ImmovableAgent {
public:

	/**
	 * This is the constructor of the class. It is used to build antenna objects.
	 * @param id the ID of this object, which is unique throughout the entire collection of agents.
	 * @param sc a pointer to a \code{SimulationConfiguration} object that contains the parameters
	 * of the simulation read from the configuration file.
	 * @param ac an \code{AntennaConfiguration} object that contains all the technical parameters of an antenna, together with its type.
	 * These parameters are specified in the antennas' configuration file.
	 * @param factory a pointer to an \code{EventFactory} object used to create \code{Event} objects according to the event type
	 * specified in the simulation configuration file.
	 */
	explicit Antenna(const unsigned long id, SimulationConfiguration* sc, AntennaConfiguration ac, EventFactory* factory);

	/**
	 * Destructor of the class. It closes the file where the Antenna dumps the registered events during the simulation.
	 */
	virtual ~Antenna();

	/**
	 * Overrides the same method from the superclass. It is used to write the parameters of the \code{Antenna}
	 * object to a \code{string} object.
	 * @return a \code{string} object that describes the parameters of the Antenna. The string representation of an \code{Antenna} object contains:
	 * \li location on map
	 * \li id
	 * \li power
	 * \li the maximum number of mobile devices that can be handled by this antenna
	 * \li the path loss exponent
	 * \li the Mobile Network Operator that owns this antenna
	 *
	 */
	const string toString(bool detailed = false) const override;

	/**
	 * Builds a \code{string} object the contains the header corresponding to the \code{string} object returned by the \code{toString(detailed)} method. Each value in the
	 * \code{string} returned by \code{toString(detailed)} method has a column name in the \code{string} object returned by this function.  This is a static method since
	 * the header should be the same for all antennas.
	 * @param detailed if false, the header is build for the string representation returned by \code{toString(false)}, otherwise
	 * the header corresponds to the string returned by \code{toString(true)}.
	 * @return a \code{string} object the contains the header corresponding to the \code{string} object returned by the \code{toString(detailed)} method
	 */
	static const string getHeader(bool detailed = false);

	/**
	 * Tries to register a mobile device as being connected to this antenna. An \code{Antenna} object maintains an internal list keeping
	 * the ids of all mobile devices connected to this object at each time instant. In case the connection is successful, the mobile device
	 * is added to this list (by calling the \code{attachDevice()} method) and a connection event (code \code{EventCode::ATTACH_DEVICE})
	 * is appended to the events file. In case the mobile device is already registered by this \code{Antenna} object in a previous
	 * time instant an "already connected" event (code EventCode::ALREADY_ATTACHED_DEVICE) is registered to the events file.
	 * In case the \code{Antenna} object has already connected the maximum allowable devices an "in range, not connected" event
	 * will be appended to the events file (code EventCode::IN_RANGE_NOT_ATTACHED_DEVICE). This means that the device is close enough
	 * to the antenna to receive a signal that can be used but the antenna cannot register the mobile device.
	 * @param device a pointer to the object that represents a mobile device (which is a subclass of the \code{HoldableAgent} class.
	 * @return true if the connection is successful, false otherwise. A connection is not successful
	 * if this \code{Antenna} already reached its maximum capacity, i.e. the maximum number of connections it can handle
	 * (a parameter read from the antenna configuration file.
	 */
	bool tryRegisterDevice(HoldableAgent *device);



	/**
	 * Disconnects a mobile device from the antenna and outputs a detach event (code EventType::DETACH_DEVICE) in the events file. This happens when the
	 * device the device has moved far enough away from the antenna so that it can no longer receive a signal that can be useful.
	 * Internally, the mobile device is removed from the list of the connected mobile devices.
	 * @param device a pointer to the device to be disconnected/detached from this antenna.
	 */
	void dettachDevice(HoldableAgent *device);

	/**
	 * Returns the antenna type: omnidirectional or directional.
	 * @return the antenna type : \code{AntennaType::OMNIDIRECTIONAL} or \code{AntennaType::DIRECTIONAL}.
	 */
	AntennaType getType() const;

	/**
	 * Computes the signal dominance given by this \code{Antenna} object in a certain location.
	 * @param p a pointer to a \code{Point} object giving the location where we want to compute the signal dominance.
	 * @return the value of the signal dominance.
	 */
	double computeSignalDominance(const Point *p) const;

	/**
	 * Computes the signal dominance given by this \code{Antenna} object in a certain location.
	 * @param c the coordinates of the location where we want to compute the signal dominance.
	 * @return the value of the signal dominance.
	 */
	double computeSignalDominance(const Coordinate c) const;

	/**
	 * Computes the signal power given by this \code{Antenna} object in a certain location.
	 * @param p a pointer to a \code{Point} object giving the location where we want to compute the signal power.
	 * @return the power of the signal in the location given by \code{Point} p.
	 */
	double computePower(const Point *p) const;

	/**
	 * Computes the signal power given by this \code{Antenna} object in a certain location.
	 * @param c the coordinates of the location where we want to compute the signal power.
	 * @return the power of the signal in the location given by \code{Coordinate} c.
	 */
	double computePower(const Coordinate c) const;

	/**
	 * Returns a pointer to a \code{MobileOperator} object representing the Mobile Network Operator that owns this antenna.
	 * @return a pointer to a \code{MobileOperator} object representing the Mobile Network Operator that owns this antenna.
	 */
	MobileOperator* getMNO() const;

	/**
	 * Builds the name of the output file where the events registered by this \code{Antenna} object during a simulation are saved.
	 * The name is built by by concatenating "Antenna", its id, "_MNO_" and the MNO name read from the
     * configuration file
	 * @return the name of the output file where the events registered by this \code{Antenna} object during a simulation are saved.
	 */
	string getAntennaOutputFileName() const;

	/**
	 * Computes the radius of the coverage area for an omnidirectional antenna. This area is a circle where the signal
	 * strength is greater than S_min parameter read from the antennas configuration file in case the simulation is based on signal strength or
	 * Q_min parameter in case the simulation uses signal dominance.
	 * @return the radius of the coverage area for an omnidirectional antenna.
	 */
	double getRmax() const;

	/**
	 * Builds a \code{wkt} string that represents the coverage area of this antenna. This area is a circle with the radius given by \code{getRmax()}
	 * in case the antenna in omnidirectional. In case of a directional antenna this coverage area is computed as a \code{Polygon} made up of points
	 * on segments starting from the antenna location where the signal strength/dominance drop below the minimum allowable limit. The segments covers the trigonometric
	 * circle, with a direction angle from the vertical axis starting from 0 and going to 2 * PI, with a step of 2PI/100.
	 * @return a \code{wkt} \code{string} object that represents the coverage area of this antenna.
	 */
	string dumpCell() const;

	/**
	 * Computes the signal strength given by this \code{Antenna} object in a certain location.
	 * @param p a pointer to a \code{Point} object giving the location where we want to compute the signal strength.
	 * @return the value of the signal strength.
	 */
	double computeSignalStrength(const Point *p) const;


	/**
	 * Writes the values of the signal strength/dominance in a .csv file.
	 * These values are computed in the center of each tile covering the map. The name of the file is obtained
	 * from the \code{MobileOperator} object that owns this antenna, by calling \code{getSignalFile()}. The strength or dominance
	 * is chosen according to the handover mechanism specified in the simulation configuration file.
	 */
	void dumpSignal() const;

	/**
	 * Builds a \code{string} object representing the header of the events file. Since the structure of the events files is the same
	 * for all \{Antenna} objects, this is a static method. The fields included in the header depend of the type of events used in
	 * a simulation.
	 * @param evType the event type, which can be \code{EventType::CELLID} or \code{EventType::CELLIDTA}.
	 * @return a \code{string} object with the header of the events file.
	 */
	static string getEventHeader(EventType evType);



private:

	void attachDevice(HoldableAgent *device);
	bool alreadyRegistered(HoldableAgent *ag);
	//void registerEvent(HoldableAgent *ag, const EventCode event, const bool verbose);
	void registerEvent(Event *ev, Point *evtLocation);
	unsigned long getNumActiveConections();
	double S0() const;
	double SDist(double dist) const;
	double computeSignalQualityOmnidirectional(const Coordinate c) const;
	double computeSignalQualityDirectional(const Coordinate c) const;
	double computeSignalStrengthDirectional(const Coordinate c) const;
	double computeSignalStrengthOmnidirectional(const Coordinate c) const;

	void setLocationWithElevation();
	double projectToEPlane(double b, double c, double beta) const;
	vector<pair<double, double>> createMapping(double dbBack) const;
	double getMin3db(double sd, double dbBack) const;
	double norm_dBLoss(double angle, double dbBack, double sd) const;
	double normalizeAngle(double angle) const;
	double searchMin(double dg, vector<pair<double, double>> _3dBDegrees) const;
	double findSD(double beamWidth, double dbBack, vector<pair<double, double>> &mapping) const;

	Geometry* getCoverageAreaOmnidirectional() const;
	Geometry* getCoverageAreaDirectional() const;
	void setCell(HoldableAgent::CONNECTION_TYPE handoverMechanism);
	double S(double dist) const;
	Geometry* getCoverageArea();
	double computeSignalStrength(const Coordinate c) const;
	double computeSignalMeasure(HoldableAgent::CONNECTION_TYPE handoverType, const Coordinate c) const;
	EventConfig* buildEventConfig(EventType evType, EventCode code,	HoldableAgent *device);
	unsigned long getMaxConnections() const;
	double getPower() const;
	double getAttenuationFactor() const;
	string getTypeName() const;
	double getSmin() const;
	double getQmin() const;
	double getSmid() const;
	double getSSteep() const;
	double getTilt() const;
	double getAzimDBBack() const;
	double getElevDBBack() const;
	double getBeamH() const;
	double getBeamV() const;
	double getDirection() const;
	double getHeight() const;

	Geometry *m_cell;
	vector<HoldableAgent*> m_devices;
	ofstream m_file;
	double m_S0;
	double m_rmax;
	vector<pair<double, double>> m_mapping_azim;
	vector<pair<double, double>> m_mapping_elev;
	double m_sd_azim;
	double m_sd_elev;

	EventFactory* m_eventFactory;

	AntennaConfiguration m_antennaConfig;
	SimulationConfiguration* m_simConfig;

	static const string EventHeaderCellID;
	static const string EventHeaderCellIDTA;
	static const double delta4G;
	static const double delta3G;
	static const unsigned int MAXTA4G;
	static const unsigned int MAXTA3G;
};

#endif /* ANTENNA_H_ */
