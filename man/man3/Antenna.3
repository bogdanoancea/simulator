.TH "Antenna" 3 "Wed May 19 2021" "Simulator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Antenna
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Antenna\&.h>\fP
.PP
Inherits \fBImmovableAgent\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAntenna\fP (const unsigned long id, \fBSimulationConfiguration\fP *sc, \fBAntennaConfiguration\fP ac, \fBEventFactory\fP *factory)"
.br
.ti -1c
.RI "virtual \fB~Antenna\fP ()"
.br
.ti -1c
.RI "const string \fBtoString\fP (bool detailed=false) const override"
.br
.ti -1c
.RI "bool \fBtryRegisterDevice\fP (HoldableAgent *device)"
.br
.ti -1c
.RI "void \fBdettachDevice\fP (HoldableAgent *device)"
.br
.ti -1c
.RI "\fBAntennaType\fP \fBgetType\fP () const"
.br
.ti -1c
.RI "double \fBcomputeSignalDominance\fP (const Point *p) const"
.br
.ti -1c
.RI "double \fBcomputeSignalDominance\fP (const Coordinate c) const"
.br
.ti -1c
.RI "double \fBcomputePower\fP (const Point *p) const"
.br
.ti -1c
.RI "double \fBcomputePower\fP (const Coordinate c) const"
.br
.ti -1c
.RI "MobileOperator * \fBgetMNO\fP () const"
.br
.ti -1c
.RI "string \fBgetAntennaOutputFileName\fP () const"
.br
.ti -1c
.RI "double \fBgetRmax\fP () const"
.br
.ti -1c
.RI "string \fBdumpCell\fP () const"
.br
.ti -1c
.RI "double \fBcomputeSignalStrength\fP (const Point *p) const"
.br
.ti -1c
.RI "void \fBdumpSignal\fP () const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static const string \fBgetHeader\fP (bool detailed=false)"
.br
.ti -1c
.RI "static string \fBgetEventHeader\fP (\fBEventType\fP evType)"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBattachDevice\fP (HoldableAgent *device)"
.br
.ti -1c
.RI "bool \fBalreadyRegistered\fP (HoldableAgent *ag)"
.br
.ti -1c
.RI "void \fBregisterEvent\fP (Event *ev, Point *evtLocation)"
.br
.ti -1c
.RI "unsigned long \fBgetNumActiveConections\fP ()"
.br
.ti -1c
.RI "double \fBS0\fP () const"
.br
.ti -1c
.RI "double \fBSDist\fP (double dist) const"
.br
.ti -1c
.RI "double \fBcomputeSignalQualityOmnidirectional\fP (const Coordinate c) const"
.br
.ti -1c
.RI "double \fBcomputeSignalQualityDirectional\fP (const Coordinate c) const"
.br
.ti -1c
.RI "double \fBcomputeSignalStrengthDirectional\fP (const Coordinate c) const"
.br
.ti -1c
.RI "double \fBcomputeSignalStrengthOmnidirectional\fP (const Coordinate c) const"
.br
.ti -1c
.RI "void \fBsetLocationWithElevation\fP ()"
.br
.ti -1c
.RI "double \fBprojectToEPlane\fP (double b, double c, double beta) const"
.br
.ti -1c
.RI "vector< pair< double, double > > \fBcreateMapping\fP (double dbBack) const"
.br
.ti -1c
.RI "double \fBgetMin3db\fP (double sd, double dbBack) const"
.br
.ti -1c
.RI "double \fBnorm_dBLoss\fP (double angle, double dbBack, double sd) const"
.br
.ti -1c
.RI "double \fBnormalizeAngle\fP (double angle) const"
.br
.ti -1c
.RI "double \fBsearchMin\fP (double dg, vector< pair< double, double >> _3dBDegrees) const"
.br
.ti -1c
.RI "double \fBfindSD\fP (double beamWidth, double dbBack, vector< pair< double, double >> &mapping) const"
.br
.ti -1c
.RI "Geometry * \fBgetCoverageAreaOmnidirectional\fP () const"
.br
.ti -1c
.RI "Geometry * \fBgetCoverageAreaDirectional\fP () const"
.br
.ti -1c
.RI "void \fBsetCell\fP (HoldableAgent::CONNECTION_TYPE handoverMechanism)"
.br
.ti -1c
.RI "double \fBS\fP (double dist) const"
.br
.ti -1c
.RI "Geometry * \fBgetCoverageArea\fP ()"
.br
.ti -1c
.RI "double \fBcomputeSignalStrength\fP (const Coordinate c) const"
.br
.ti -1c
.RI "double \fBcomputeSignalMeasure\fP (HoldableAgent::CONNECTION_TYPE handoverType, const Coordinate c) const"
.br
.ti -1c
.RI "EventConfig * \fBbuildEventConfig\fP (\fBEventType\fP evType, \fBEventCode\fP code, HoldableAgent *device)"
.br
.ti -1c
.RI "unsigned long \fBgetMaxConnections\fP () const"
.br
.ti -1c
.RI "double \fBgetPower\fP () const"
.br
.ti -1c
.RI "double \fBgetAttenuationFactor\fP () const"
.br
.ti -1c
.RI "string \fBgetTypeName\fP () const"
.br
.ti -1c
.RI "double \fBgetSmin\fP () const"
.br
.ti -1c
.RI "double \fBgetQmin\fP () const"
.br
.ti -1c
.RI "double \fBgetSmid\fP () const"
.br
.ti -1c
.RI "double \fBgetSSteep\fP () const"
.br
.ti -1c
.RI "double \fBgetTilt\fP () const"
.br
.ti -1c
.RI "double \fBgetAzimDBBack\fP () const"
.br
.ti -1c
.RI "double \fBgetElevDBBack\fP () const"
.br
.ti -1c
.RI "double \fBgetBeamH\fP () const"
.br
.ti -1c
.RI "double \fBgetBeamV\fP () const"
.br
.ti -1c
.RI "double \fBgetDirection\fP () const"
.br
.ti -1c
.RI "double \fBgetHeight\fP () const"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "Geometry * \fBm_cell\fP"
.br
.ti -1c
.RI "vector< HoldableAgent * > \fBm_devices\fP"
.br
.ti -1c
.RI "ofstream \fBm_file\fP"
.br
.ti -1c
.RI "double \fBm_S0\fP"
.br
.ti -1c
.RI "double \fBm_rmax\fP"
.br
.ti -1c
.RI "vector< pair< double, double > > \fBm_mapping_azim\fP"
.br
.ti -1c
.RI "vector< pair< double, double > > \fBm_mapping_elev\fP"
.br
.ti -1c
.RI "double \fBm_sd_azim\fP"
.br
.ti -1c
.RI "double \fBm_sd_elev\fP"
.br
.ti -1c
.RI "\fBEventFactory\fP * \fBm_eventFactory\fP"
.br
.ti -1c
.RI "\fBAntennaConfiguration\fP \fBm_antennaConfig\fP"
.br
.ti -1c
.RI "\fBSimulationConfiguration\fP * \fBm_simConfig\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static const string \fBEventHeaderCellID\fP"
.br
.ti -1c
.RI "static const string \fBEventHeaderCellIDTA\fP"
.br
.ti -1c
.RI "static const double \fBdelta4G\fP"
.br
.ti -1c
.RI "static const double \fBdelta3G\fP"
.br
.ti -1c
.RI "static const unsigned int \fBMAXTA4G\fP"
.br
.ti -1c
.RI "static const unsigned int \fBMAXTA3G\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class simulates an antenna (a base transceiver station, or shortly BTS) of the mobile phone network\&. It has a fixed location on the map and registers the events generated by the interaction with the mobile devices in a \&.csv file\&. Each antenna has its own file where it saves the events and the name of this file\&. The name of this file is composed by concatenating 'Antenna', its id, '_MNO_' and the MNO name read from the configuration file\&. The are two types of antennas: omnidirectional and directional\&. An omnidirectional antenna emits homogeneous signal in all directions\&. We model the signal using two measures: 
.PD 0

.IP "\(bu" 2
the signal strength 
.IP "\(bu" 2
the signal dominance
.PP
The signal strength at distance \fIr\fP from the antenna's location is given by :
.PP
RSS(r) = 30 + 10 log10(P) - 10 gamma log10(r) where \fIP\fP is the power of the antenna in Watts and \fIgamma\fP is the attenuation factor of the signal (also called the path loss exponent),
.PP
while the signal dominance is given by:
.PP
SDM(r) = 1/(1 + exp (-Ssteep ( RSS(r) - Smid)))
.PP
where \fISsteep\fP and \fISmid\fP are parameters that should be given in the configuration file\&.
.PP
For a complete definition of the signal dominance one can consult: Tennekes M, Gootzen YAPM, Shah SH (2020) A Bayesian approach to location estimation of mobile devices from mobile network operator data\&. Research Report, Statistics Netherlands (CBS)\&.
.PP
A directional antenna has a specific signal emission pattern and one can find a description of it in the work mentioned above\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Antenna::Antenna (const unsigned long id, \fBSimulationConfiguration\fP * sc, \fBAntennaConfiguration\fP ac, \fBEventFactory\fP * factory)\fC [explicit]\fP"
This is the constructor of the class\&. It is used to build antenna objects\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP the ID of this object, which is unique throughout the entire collection of agents\&. 
.br
\fIsc\fP a pointer to a \fBSimulationConfiguration\fP object that contains the parameters of the simulation read from the configuration file\&. 
.br
\fIac\fP an \fBAntennaConfiguration\fP object that contains all the technical parameters of an antenna, together with its type\&. These parameters are specified in the antennas' configuration file\&. 
.br
\fIfactory\fP a pointer to an \fBEventFactory\fP object used to create Event objects according to the event type specified in the simulation configuration file\&. 
.RE
.PP

.SS "virtual Antenna::~Antenna ()\fC [virtual]\fP"
Destructor of the class\&. It closes the file where the \fBAntenna\fP dumps the registered events during the simulation\&. 
.SH "Member Function Documentation"
.PP 
.SS "bool Antenna::alreadyRegistered (HoldableAgent * ag)\fC [private]\fP"

.SS "void Antenna::attachDevice (HoldableAgent * device)\fC [private]\fP"

.SS "EventConfig* Antenna::buildEventConfig (\fBEventType\fP evType, \fBEventCode\fP code, HoldableAgent * device)\fC [private]\fP"

.SS "double Antenna::computePower (const Point * p) const"
Computes the signal power given by this \fBAntenna\fP object in a certain location\&. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP a pointer to a Point object giving the location where we want to compute the signal power\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the power of the signal in the location given by Point p\&. 
.RE
.PP

.SS "double Antenna::computePower (const Coordinate c) const"
Computes the signal power given by this \fBAntenna\fP object in a certain location\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP the coordinates of the location where we want to compute the signal power\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the power of the signal in the location given by Coordinate c\&. 
.RE
.PP

.SS "double Antenna::computeSignalDominance (const Point * p) const"
Computes the signal dominance given by this \fBAntenna\fP object in a certain location\&. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP a pointer to a Point object giving the location where we want to compute the signal dominance\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the value of the signal dominance\&. 
.RE
.PP

.SS "double Antenna::computeSignalDominance (const Coordinate c) const"
Computes the signal dominance given by this \fBAntenna\fP object in a certain location\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP the coordinates of the location where we want to compute the signal dominance\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the value of the signal dominance\&. 
.RE
.PP

.SS "double Antenna::computeSignalMeasure (HoldableAgent::CONNECTION_TYPE handoverType, const Coordinate c) const\fC [private]\fP"

.SS "double Antenna::computeSignalQualityDirectional (const Coordinate c) const\fC [private]\fP"

.SS "double Antenna::computeSignalQualityOmnidirectional (const Coordinate c) const\fC [private]\fP"

.SS "double Antenna::computeSignalStrength (const Point * p) const"
Computes the signal strength given by this \fBAntenna\fP object in a certain location\&. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP a pointer to a Point object giving the location where we want to compute the signal strength\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the value of the signal strength\&. 
.RE
.PP

.SS "double Antenna::computeSignalStrength (const Coordinate c) const\fC [private]\fP"

.SS "double Antenna::computeSignalStrengthDirectional (const Coordinate c) const\fC [private]\fP"

.SS "double Antenna::computeSignalStrengthOmnidirectional (const Coordinate c) const\fC [private]\fP"

.SS "vector<pair<double, double> > Antenna::createMapping (double dbBack) const\fC [private]\fP"

.SS "void Antenna::dettachDevice (HoldableAgent * device)"
Disconnects a mobile device from the antenna and outputs a detach event (code EventType::DETACH_DEVICE) in the events file\&. This happens when the device the device has moved far enough away from the antenna so that it can no longer receive a signal that can be useful\&. Internally, the mobile device is removed from the list of the connected mobile devices\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP a pointer to the device to be disconnected/detached from this antenna\&. 
.RE
.PP

.SS "string Antenna::dumpCell () const"
Builds a \fCwkt\fP string that represents the coverage area of this antenna\&. This area is a circle with the radius given by \fBgetRmax()\fP in case the antenna in omnidirectional\&. In case of a directional antenna this coverage area is computed as a Polygon made up of points on segments starting from the antenna location where the signal strength/dominance drop below the minimum allowable limit\&. The segments covers the trigonometric circle, with a direction angle from the vertical axis starting from 0 and going to 2 * PI, with a step of 2PI/100\&. 
.PP
\fBReturns:\fP
.RS 4
a \fCwkt\fP string object that represents the coverage area of this antenna\&. 
.RE
.PP

.SS "void Antenna::dumpSignal () const"
Writes the values of the signal strength/dominance in a \&.csv file\&. These values are computed in the center of each tile covering the map\&. The name of the file is obtained from the MobileOperator object that owns this antenna, by calling getSignalFile()\&. The strength or dominance is chosen according to the handover mechanism specified in the simulation configuration file\&. 
.SS "double Antenna::findSD (double beamWidth, double dbBack, vector< pair< double, double >> & mapping) const\fC [private]\fP"

.SS "string Antenna::getAntennaOutputFileName () const"
Builds the name of the output file where the events registered by this \fBAntenna\fP object during a simulation are saved\&. The name is built by by concatenating 'Antenna', its id, '_MNO_' and the MNO name read from the configuration file 
.PP
\fBReturns:\fP
.RS 4
the name of the output file where the events registered by this \fBAntenna\fP object during a simulation are saved\&. 
.RE
.PP

.SS "double Antenna::getAttenuationFactor () const\fC [private]\fP"

.SS "double Antenna::getAzimDBBack () const\fC [private]\fP"

.SS "double Antenna::getBeamH () const\fC [private]\fP"

.SS "double Antenna::getBeamV () const\fC [private]\fP"

.SS "Geometry* Antenna::getCoverageArea ()\fC [private]\fP"

.SS "Geometry* Antenna::getCoverageAreaDirectional () const\fC [private]\fP"

.SS "Geometry* Antenna::getCoverageAreaOmnidirectional () const\fC [private]\fP"

.SS "double Antenna::getDirection () const\fC [private]\fP"

.SS "double Antenna::getElevDBBack () const\fC [private]\fP"

.SS "static string Antenna::getEventHeader (\fBEventType\fP evType)\fC [static]\fP"
Builds a string object representing the header of the events file\&. Since the structure of the events files is the same for all \fBAntenna\fP objects, this is a static method\&. The fields included in the header depend of the type of events used in a simulation\&. 
.PP
\fBParameters:\fP
.RS 4
\fIevType\fP the event type, which can be \fBEventType::CELLID\fP or \fBEventType::CELLIDTA\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
a string object with the header of the events file\&. 
.RE
.PP

.SS "static const string Antenna::getHeader (bool detailed = \fCfalse\fP)\fC [static]\fP"
Builds a string object the contains the header corresponding to the string object returned by the toString(detailed) method\&. Each value in the string returned by toString(detailed) method has a column name in the string object returned by this function\&. This is a static method since the header should be the same for all antennas\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdetailed\fP if false, the header is build for the string representation returned by toString(false), otherwise the header corresponds to the string returned by toString(true)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
a string object the contains the header corresponding to the string object returned by the toString(detailed) method\&. 
.RE
.PP

.SS "double Antenna::getHeight () const\fC [private]\fP"

.SS "unsigned long Antenna::getMaxConnections () const\fC [private]\fP"

.SS "double Antenna::getMin3db (double sd, double dbBack) const\fC [private]\fP"

.SS "MobileOperator* Antenna::getMNO () const"
Returns a pointer to a MobileOperator object representing the Mobile Network Operator that owns this antenna\&. 
.PP
\fBReturns:\fP
.RS 4
a pointer to a MobileOperator object representing the Mobile Network Operator that owns this antenna\&. 
.RE
.PP

.SS "unsigned long Antenna::getNumActiveConections ()\fC [private]\fP"

.SS "double Antenna::getPower () const\fC [private]\fP"

.SS "double Antenna::getQmin () const\fC [private]\fP"

.SS "double Antenna::getRmax () const"
Computes the radius of the coverage area for an omnidirectional antenna\&. This area is a circle where the signal strength is greater than S_min parameter read from the antennas configuration file in case the simulation is based on signal strength or Q_min parameter in case the simulation uses signal dominance\&. 
.PP
\fBReturns:\fP
.RS 4
the radius of the coverage area for an omnidirectional antenna\&. 
.RE
.PP

.SS "double Antenna::getSmid () const\fC [private]\fP"

.SS "double Antenna::getSmin () const\fC [private]\fP"

.SS "double Antenna::getSSteep () const\fC [private]\fP"

.SS "double Antenna::getTilt () const\fC [private]\fP"

.SS "\fBAntennaType\fP Antenna::getType () const"
Returns the antenna type: omnidirectional or directional\&. 
.PP
\fBReturns:\fP
.RS 4
the antenna type : \fBAntennaType::OMNIDIRECTIONAL\fP or \fBAntennaType::DIRECTIONAL\fP\&. 
.RE
.PP

.SS "string Antenna::getTypeName () const\fC [private]\fP"

.SS "double Antenna::norm_dBLoss (double angle, double dbBack, double sd) const\fC [private]\fP"

.SS "double Antenna::normalizeAngle (double angle) const\fC [private]\fP"

.SS "double Antenna::projectToEPlane (double b, double c, double beta) const\fC [private]\fP"

.SS "void Antenna::registerEvent (Event * ev, Point * evtLocation)\fC [private]\fP"

.SS "double Antenna::S (double dist) const\fC [private]\fP"

.SS "double Antenna::S0 () const\fC [private]\fP"

.SS "double Antenna::SDist (double dist) const\fC [private]\fP"

.SS "double Antenna::searchMin (double dg, vector< pair< double, double >> _3dBDegrees) const\fC [private]\fP"

.SS "void Antenna::setCell (HoldableAgent::CONNECTION_TYPE handoverMechanism)\fC [private]\fP"

.SS "void Antenna::setLocationWithElevation ()\fC [private]\fP"

.SS "const string Antenna::toString (bool detailed = \fCfalse\fP) const\fC [override]\fP"
Overrides the same method from the superclass\&. It is used to write the parameters of the \fBAntenna\fP object to a string object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdetailed\fP if false the output string will contain the following values: 
.PD 0

.IP "\(bu" 2
location on map 
.IP "\(bu" 2
id 
.IP "\(bu" 2
power 
.IP "\(bu" 2
the maximum number of mobile devices that can be handled by this antenna 
.IP "\(bu" 2
the path loss exponent 
.IP "\(bu" 2
the Mobile Network Operator that owns this antenna
.PP
otherwise it will contain: 
.PD 0

.IP "\(bu" 2
location on map 
.IP "\(bu" 2
id 
.IP "\(bu" 2
Mobile Operator name 
.IP "\(bu" 2
the maximum number of mobile devices that can be handled by this antenna 
.IP "\(bu" 2
the power of this antenna 
.IP "\(bu" 2
the path loss exponent (attenuation factor) 
.IP "\(bu" 2
the antenna type (directional, omnidirectional) 
.IP "\(bu" 2
the S_min value (minimum signal strength detectable by mobile devices) 
.IP "\(bu" 2
the Q_min value (minimum signal dominance usable by mobile devices) 
.IP "\(bu" 2
the Ssteep parameter value 
.IP "\(bu" 2
the Smid parameter value 
.IP "\(bu" 2
the tilt value (only for directional antennas) 
.IP "\(bu" 2
the azimDBback parameter value (only for directional antennas) 
.IP "\(bu" 2
the elevDBback parameter value (only for directional antennas) 
.IP "\(bu" 2
the beamH parameter value (only for directional antennas) 
.IP "\(bu" 2
the beamH parameter value (only for directional antennas) 
.IP "\(bu" 2
the direction angle (only for directional antennas) 
.IP "\(bu" 2
the height of the antenna 
.IP "\(bu" 2
the tile number of the location where this antenna is placed on the map\&.
.PP
.RE
.PP
\fBReturns:\fP
.RS 4
a string object that describes the parameters of the \fBAntenna\fP\&. The string representation of an \fBAntenna\fP object depends o the value of the parameter \fCdetailed\fP (see the above explanation)\&. 
.RE
.PP

.SS "bool Antenna::tryRegisterDevice (HoldableAgent * device)"
Tries to register a mobile device as being connected to this antenna\&. An \fBAntenna\fP object maintains an internal list keeping the ids of all mobile devices connected to this object at each time instant\&. In case the connection is successful, the mobile device is added to this list (by calling the \fBattachDevice()\fP method) and a connection event (code \fBEventCode::ATTACH_DEVICE\fP) is appended to the events file\&. In case the mobile device is already registered by this \fBAntenna\fP object in a previous time instant an 'already connected' event (code \fBEventCode::ALREADY_ATTACHED_DEVICE\fP) is registered to the events file\&. In case the \fBAntenna\fP object has already connected the maximum allowable devices an 'in range, not connected' event will be appended to the events file (code \fBEventCode::IN_RANGE_NOT_ATTACHED_DEVICE\fP)\&. This means that the device is close enough to the antenna to receive a signal that can be used but the antenna cannot register the mobile device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP a pointer to the object that represents a mobile device (which is a subclass of the HoldableAgent class\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the connection is successful, false otherwise\&. A connection is not successful if this \fBAntenna\fP already reached its maximum capacity, i\&.e\&. the maximum number of connections it can handle (a parameter read from the antenna configuration file)\&. 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "const double Antenna::delta3G\fC [static]\fP, \fC [private]\fP"

.SS "const double Antenna::delta4G\fC [static]\fP, \fC [private]\fP"

.SS "const string Antenna::EventHeaderCellID\fC [static]\fP, \fC [private]\fP"

.SS "const string Antenna::EventHeaderCellIDTA\fC [static]\fP, \fC [private]\fP"

.SS "\fBAntennaConfiguration\fP Antenna::m_antennaConfig\fC [private]\fP"

.SS "Geometry* Antenna::m_cell\fC [private]\fP"

.SS "vector<HoldableAgent*> Antenna::m_devices\fC [private]\fP"

.SS "\fBEventFactory\fP* Antenna::m_eventFactory\fC [private]\fP"

.SS "ofstream Antenna::m_file\fC [private]\fP"

.SS "vector<pair<double, double> > Antenna::m_mapping_azim\fC [private]\fP"

.SS "vector<pair<double, double> > Antenna::m_mapping_elev\fC [private]\fP"

.SS "double Antenna::m_rmax\fC [private]\fP"

.SS "double Antenna::m_S0\fC [private]\fP"

.SS "double Antenna::m_sd_azim\fC [private]\fP"

.SS "double Antenna::m_sd_elev\fC [private]\fP"

.SS "\fBSimulationConfiguration\fP* Antenna::m_simConfig\fC [private]\fP"

.SS "const unsigned int Antenna::MAXTA3G\fC [static]\fP, \fC [private]\fP"

.SS "const unsigned int Antenna::MAXTA4G\fC [static]\fP, \fC [private]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for Simulator from the source code\&.
